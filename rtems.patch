diff --git a/Makefile b/Makefile
new file mode 100644
index 00000000..b64d6b5e
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,170 @@
+include $(RTEMS_MAKEFILE_PATH)/Makefile.inc
+include $(RTEMS_CUSTOM)
+include $(PROJECT_ROOT)/make/leaf.cfg
+
+#### CONFIG ####################################################################
+#For debugging symbols add -DLWIP_DEBUG
+# COMPILER/LINKER
+CFLAGS+=-g -O2   \
+ -Wall
+
+# OUTPUT
+LWIP_EXEC=lwip
+
+#### PATHS #####################################################################
+
+# LWIP
+LWIP_PATH=.
+LWIP_SRC_PATH=$(LWIP_PATH)/src
+LWIP_API_PATH=$(LWIP_SRC_PATH)/api
+LWIP_CORE_PATH=$(LWIP_SRC_PATH)/core
+LWIP_INCL_PATH=$(LWIP_SRC_PATH)/include
+LWIP_NETIF_PATH=$(LWIP_SRC_PATH)/netif
+
+# ARCH
+LWIPARCH_PATH=$(LWIP_PATH)/contrib/ports/rtems
+LWIPARCH_SRC_PATH=$(LWIPARCH_PATH)
+LWIPARCH_INCL_PATH=$(LWIPARCH_PATH)/include
+
+# DRIVER
+LWIPDRIVER_PATH=$(LWIP_PATH)/ports
+LWIPDRIVER_SRC_PATH=$(LWIPDRIVER_PATH)/netif
+LWIPDRIVER_INCL_PATH=$(LWIPDRIVER_PATH)/include/netif
+
+#### SOURCES ###################################################################
+
+## CORE
+CORE_SRC=$(wildcard $(LWIP_CORE_PATH)/*.c)
+
+## IPv4
+IPV4_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv4/*.c)
+
+## IPv6
+IPV6_SRC=$(wildcard $(LWIP_CORE_PATH)/ipv6/*.c)
+
+## SNMP
+SNMP_SRC=$(wildcard $(LWIP_CORE_PATH)/snmp/*.c)
+
+## API
+API_SRC=$(wildcard $(LWIP_API_PATH)/*.c )
+
+## NETIF
+NETIF_SRC=$(wildcard $(LWIP_NETIF_PATH)/*.c) \
+          $(wildcard $(LWIP_NETIF_PATH)/ppp/*.c) \
+          $(wildcard $(LWIP_NETIF_PATH)/ppp/polarssl/*.c)
+
+
+ARCH_SRC=$(wildcard $(LWIPARCH_SRC_PATH)/*.c)
+
+# DRIVER
+DRIVER_SRC=$(wildcard $(LWIPDRIVER_SRC_PATH)/*.c ) \
+           $(wildcard $(LWIPDRIVER_SRC_PATH)/*.S )
+
+
+SOURCES =  $(DRIVER_SRC) $(SNMP_SRC)\
+           $(CORE_SRC) $(IPV4_SRC) $(API_SRC) $(NETIF_SRC) $(ARCH_SRC)
+
+
+#### HEADERS ###################################################################
+
+## CORE
+CORE_H=$(LWIP_INCL_PATH)
+
+## IPv4
+#IPV4_H=$(LWIP_INCL_PATH)/ipv4
+
+## IPv6
+#IPV6_H=$(LWIP_INCL_PATH)/ipv6
+
+## POSIX
+POSIX_H=$(LWIP_INCL_PATH)/posix
+
+##POSIX_SYS
+POSIX_SYS_H=$(LWIP_INCL_PATH)/posix/sys
+
+
+## NETIF
+NETIF_H=$(LWIP_INCL_PATH)/netif
+NETIF_H_PPP=$(LWIP_INCL_PATH)/netif/ppp
+NETIF_H_PPP_POLARSSL=$(LWIP_INCL_PATH)/netif/ppp/polarssl
+
+## ARCH
+ARCH_H=$(LWIPARCH_INCL_PATH)
+
+## DRIVER
+DRIVER_H=$(LWIPDRIVER_INCL_PATH)
+
+# HEADERS
+HEADERS=-I$(CORE_H) -I$(POSIX_H) -I$(POSIX_SYS_H) -I$(NETIF_H) \
+        -I$(NETIF_H_PPP) -I$(NETIF_H_PPP_POLARSSL) -I$(ARCH_H) \
+        -I$(DRIVER_H)
+
+
+################################################################################
+
+
+BIN=${ARCH}/$(LWIP_EXEC).bin
+LIB=${ARCH}/lib$(LWIP_EXEC).a
+
+# optional managers required
+MANAGERS=all
+
+# C source names
+CSRCS=$(filter %.c ,$(SOURCES))
+COBJS=$(patsubst %.c,${ARCH}/%.o,$(notdir $(CSRCS)))
+
+ASMSRCS=$(filter %.S , $(SOURCES))
+ASMOBJS=$(patsubst %.S,${ARCH}/%.o,$(notdir $(ASMSRCS)))
+
+OBJS=$(COBJS) $(ASMOBJS)
+
+all:${ARCH} $(LIB)
+
+$(LIB): $(OBJS)
+	$(AR)  rcs  $@ $^
+
+${ARCH}/%.o: $(LWIP_CORE_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv4/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_CORE_PATH)/ipv6/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_CORE_PATH)/snmp/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_API_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_NETIF_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIP_NETIF_PATH)/ppp/polarssl/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIPARCH_SRC_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.S
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+${ARCH}/%.o: $(LWIPDRIVER_SRC_PATH)/%.c
+	${COMPILE.c} $(AM_CPPFLAGS) $(AM_CXXFLAGS) -o $@ $<
+
+INSTALL_DIR=$(RTEMS_MAKEFILE_PATH)/lwip
+
+install:
+	rm -rf $(INSTALL_DIR)
+	mkdir -p $(INSTALL_DIR)/include
+	mkdir -p $(INSTALL_DIR)/lib
+	cp $(LIB) $(INSTALL_DIR)/lib
+	cp -r $(CORE_H) $(INSTALL_DIR)
+	cp -r $(LWIPARCH_INCL_PATH)/* $(INSTALL_DIR)/include
+# cp -r $(LWIPARCH_INCL_PATH)/arch $(INSTALL_DIR)/include
+
+CPPFLAGS+=$(HEADERS)
diff --git a/contrib/ports/rtems/include/arch/cc.h b/contrib/ports/rtems/include/arch/cc.h
new file mode 100644
index 00000000..84138ff1
--- /dev/null
+++ b/contrib/ports/rtems/include/arch/cc.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is system adaptation of the lwIP TCP/IP stack
+ * by Adam Dunkels <adam@sics.se> for RTEMS system.
+ *
+ * Author: Premysl Houdek <houdepre@fel.cvut.cz>
+ * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ * Industrial Informatics Group, FEE, Czech Technical University in Prague
+ *
+ */
+/*
+ * settings to adapt lwIP for compiler and machine architecture for RTEMS/GCC
+ * DETAILS: ./lwip/doc/sys_arch.txt
+ */
+#ifndef __CC_H__
+#define __CC_H__
+
+#include <stdio.h>
+#include <rtems/malloc.h>  /*printk*/
+#include <inttypes.h>
+#include <malloc.h>
+#include <sys/time.h>
+#include <rtems.h>
+#include <sys/errno.h>
+#include <endian.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <sys/uio.h> /*struct iovec*/
+
+#ifndef iovec
+#define iovec iovec
+#endif
+
+/* This file must either include a system-local <errno.h> which defines
+   the standard *nix error codes, or it should #define LWIP_PROVIDE_ERRNO
+   to make lwip/arch.h define the codes which are used throughout. */
+#undef LWIP_PROVIDE_ERRNO
+
+#if !defined(LWIP_NO_STDINT_H)
+#define LWIP_NO_STDINT_H 0
+#endif
+
+#if LWIP_NO_STDINT_H
+/* type definitions */
+typedef uint8_t             u8_t;
+typedef int8_t              s8_t;
+typedef uint16_t            u16_t;
+typedef int16_t             s16_t;
+typedef uint32_t            u32_t;
+typedef int32_t             s32_t;
+typedef u32_t               mem_ptr_t;
+
+#endif /*LWIP_NO_STDINT_H*/
+
+#if !defined(LWIP_NO_INTTYPES_H)
+#define LWIP_NO_INTTYPES_H 0
+#endif
+
+#if LWIP_NO_INTTYPES_H
+/* Define (sn)printf formatters for these lwIP types */
+#define U16_F PRIu16
+#define S16_F PRId16
+#define X16_F PRIx16
+#define U32_F PRIu32
+#define S32_F PRId32
+#define X32_F PRIx32
+#endif /*LWIP_NO_INTTYPES_H*/
+
+#if defined(__arm__) && defined(__ARMCC_VERSION)
+//
+// Setup PACKing macros for KEIL/RVMDK Tools
+//
+    #define PACK_STRUCT_BEGIN __packed
+    #define PACK_STRUCT_STRUCT
+    #define PACK_STRUCT_END
+    #define PACK_STRUCT_FIELD(x) x
+#elif defined (__IAR_SYSTEMS_ICC__)
+//
+// Setup PACKing macros for IAR Tools
+//
+    #define PACK_STRUCT_BEGIN
+    #define PACK_STRUCT_STRUCT
+    #define PACK_STRUCT_END
+    #define PACK_STRUCT_FIELD(x) x
+    #define PACK_STRUCT_USE_INCLUDES
+#elif defined (__TMS470__)
+    #define PACK_STRUCT_BEGIN
+    #define PACK_STRUCT_STRUCT
+    #define PACK_STRUCT_END
+    #define PACK_STRUCT_FIELD(x) x
+#else
+//
+// Setup PACKing macros for GCC Tools
+//
+    #define PACK_STRUCT_BEGIN
+    #define PACK_STRUCT_STRUCT __attribute__ ((__packed__))
+    #define PACK_STRUCT_END
+    #define PACK_STRUCT_FIELD(x) x
+#endif
+
+/*
+ *     1 - load byte by byte, construct 16 bits word and add: not efficient for most platforms
+ *     2 - load first byte if odd address, loop processing 16 bits words, add last byte.
+ *     3 - load first byte and word if not 4 byte aligned, loop processing 32 bits words, add last word/byte.
+ *
+ *     see inet_chksum.c
+ */
+#ifndef LWIP_CHKSUM_ALGORITHM
+#define LWIP_CHKSUM_ALGORITHM 2
+#endif
+
+/* this is used for 1) displaying statistics and 2) lwip debugging (set appropriate debugging level in lwipopts.h) */
+//#ifdef LWIP_DEBUG
+
+
+#define LWIP_PLATFORM_DIAG(expr)        printk expr
+
+//#else
+//#define LWIP_PLATFORM_DIAG(expr)
+//#endif
+
+//#define DEBUG
+#ifdef DEBUG
+
+/* for passing arguments to print function */
+#define CC_ASSERT(message, assertion) do { if (!(assertion)) \
+					     LWIP_PLATFORM_DIAG(message); } while (0)
+
+//extern void __error__(char *pcFilename, unsigned long ulLine);
+#define LWIP_PLATFORM_ASSERT(expr)      printk((const char *)expr)
+/*
+{                                       \
+    if(!(expr))                         \
+    {                                   \
+        __error__(__FILE__, __LINE__);  \
+    }                                   \
+}
+*/
+#else
+#define LWIP_PLATFORM_ASSERT(expr)
+#define CC_ASSERT(message, assertion)
+#endif /* DEBUG */
+
+/* "lightweight" synchronization mechanisms */
+/* #define SYS_ARCH_DECL_PROTECT(x) */ /* declare a protection state variable */
+/* #define SYS_ARCH_PROTECT(x) */ /* enter protection mode */
+/* #define SYS_ARCH_UNPROTECT(x) */ /* leave protection mode */
+
+/* 32-bit random value used by igmp and others */
+#define LWIP_RAND() ((uint32_t)random())
+
+#endif /* __CC_H__ */
diff --git a/contrib/ports/rtems/include/arch/perf.h b/contrib/ports/rtems/include/arch/perf.h
new file mode 100755
index 00000000..d7541570
--- /dev/null
+++ b/contrib/ports/rtems/include/arch/perf.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __PERF_H__
+#define __PERF_H__
+
+#define PERF_START    /* null definition */
+#define PERF_STOP(x)  /* null definition */
+
+#endif /* __PERF_H__ */
diff --git a/contrib/ports/rtems/include/arch/sys_arch.h b/contrib/ports/rtems/include/arch/sys_arch.h
new file mode 100644
index 00000000..2ad1fcc3
--- /dev/null
+++ b/contrib/ports/rtems/include/arch/sys_arch.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is system adaptation of the lwIP TCP/IP stack
+ * by Adam Dunkels <adam@sics.se> for RTEMS system.
+ *
+ * Author: Premysl Houdek <houdepre@fel.cvut.cz>
+ * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ * Industrial Informatics Group, FEE, Czech Technical University in Prague
+ *
+ */
+/*
+ * mapping of lwIP system dependencies to RTEMS system services and types.
+ * DETAILS: ./lwip/doc/sys_arch.txt
+ */
+#ifndef __ARCH_SYS_ARCH_H__
+#define __ARCH_SYS_ARCH_H__
+
+#include <bsp/irq-generic.h>
+#include <rtems/rtems/intr.h>
+#include <rtems/rtems/sem.h>
+
+/* Typedefs for the various port-specific types. */
+#if defined(NO_SYS) && NO_SYS
+#error "RTEMS SYS_ARCH cannot be compiled in NO_SYS variant"
+#endif
+
+#define sys_arch_printk printk
+
+typedef struct {
+  rtems_id mailbox;
+  rtems_id sem;
+} port_mailbox_t;
+
+typedef struct {
+  rtems_id semaphore;
+} port_sem_t;
+
+typedef struct {
+  rtems_id mutex;
+} port_mutex_t;
+
+typedef port_mailbox_t sys_mbox_t;
+typedef port_sem_t sys_sem_t;
+typedef rtems_id sys_thread_t;
+typedef port_mutex_t sys_mutex_t;
+#include <rtems/score/threaddispatch.h>
+#ifdef RTEMS_SMP
+typedef Per_CPU_Control *sys_prot_t;
+#else
+typedef rtems_interrupt_level sys_prot_t;
+#endif
+
+void sys_arch_delay(unsigned int x);
+void sys_sem_signal_from_ISR(sys_sem_t *sem);
+
+typedef void sys_irqreturn_t;
+#define SYS_IRQ_NONE ((void)0)
+#define SYS_IRQ_HANDLED ((void)1)
+#define SYS_IRQ_RETVAL(x) (IRQ_HANDLED)
+typedef rtems_interrupt_handler sys_irq_handler_t;
+#define SYS_IRQ_HANDLER_FNC(M_fnc_name)                                        \
+  sys_irqreturn_t M_fnc_name(void *__irq_handler_context)
+#define sys_irq_handler_get_context() (__irq_handler_context)
+
+int sys_request_irq(unsigned int irqnum, sys_irq_handler_t handler,
+                    unsigned long flags, const char *name, void *context);
+
+static inline void sys_arch_mask_interrupt_source(unsigned int x) {
+  bsp_interrupt_vector_disable(x);
+}
+
+static inline void sys_arch_unmask_interrupt_source(unsigned int x) {
+  bsp_interrupt_vector_enable(x);
+}
+
+sys_prot_t sys_arch_protect();
+
+void sys_arch_unprotect(sys_prot_t pval);
+
+static inline void sys_arch_data_sync_barier(void) {
+#ifdef __arm__
+  _ARM_Data_synchronization_barrier();
+#endif
+}
+
+/*
+ * This must match the definition in lwIP's lwip/sys.h
+ * It can't be included from there since this file is included there before the
+ * typedef.
+ */
+typedef void (*lwip_thread_fn)(void *arg);
+
+/* This is a thread creator that can be passed CPU affinity */
+sys_thread_t sys_thread_new_affinity(const char *name, lwip_thread_fn function,
+                                     void *arg, int stack_size, int prio,
+                                     cpu_set_t *set);
+#endif /* __ARCH_SYS_ARCH_H__ */
diff --git a/contrib/ports/rtems/include/common_lwipopts.h b/contrib/ports/rtems/include/common_lwipopts.h
new file mode 100644
index 00000000..65d4ba7e
--- /dev/null
+++ b/contrib/ports/rtems/include/common_lwipopts.h
@@ -0,0 +1,181 @@
+/**
+ * \file lwipopts.h - Configuration options for lwIP
+ *
+ * Copyright (c) 2010 Texas Instruments Incorporated
+ */
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef __LWIPOPTS_H__
+#define __LWIPOPTS_H__
+
+/*****************************************************************************
+**                           CONFIGURATIONS
+*****************************************************************************/
+
+/*
+** The below macro should be defined for using lwIP with cache. For cache
+** enabling, pbuf pool shall be cache line aligned. This is done by using
+** separate pool for each memory. The alignment of pbuf pool to cache line
+** size is done in /ports/cpsw/include/arch/cc.h.
+*/
+/*#define LWIP_CACHE_ENABLED*/
+
+#define SOC_CACHELINE_SIZE_BYTES                                               \
+  64 /* Number of bytes in                                                     \
+        a cache line */
+/*
+** The timeout for DHCP completion. lwIP library will wait for DHCP
+** completion for (LWIP_DHCP_TIMEOUT / 100) seconds.
+*/
+#define LWIP_DHCP_TIMEOUT 500
+
+/*
+** The number of times DHCP is attempted. Each time, the library will wait
+** for (LWIP_DHCP_TIMEOUT / 100) seconds for DHCP completion.
+*/
+#define NUM_DHCP_TRIES 5
+
+#define LWIP_ETHERNET 1
+#define LWIP_ARP 1
+
+/*****************************************************************************
+**            lwIP SPECIFIC DEFINITIONS - To be used by lwIP stack
+*****************************************************************************/
+#define HOST_TMR_INTERVAL 0
+#define DYNAMIC_HTTP_HEADERS
+
+/*****************************************************************************
+**                    Platform specific locking
+*****************************************************************************/
+#define SYS_LIGHTWEIGHT_PROT 1
+#define NO_SYS 0
+#define NO_SYS_NO_TIMERS 0
+
+/*****************************************************************************
+**                          Memory Options
+*****************************************************************************/
+#define MEM_ALIGNMENT 4
+#define MEM_SIZE (256 * 1024) /* 128K */
+
+#define MEMP_NUM_PBUF 96
+#define MEMP_NUM_TCP_PCB 32
+#define MEMP_NUM_TCP_SEG 32
+#define PBUF_POOL_SIZE 512
+
+#ifdef LWIP_CACHE_ENABLED
+#define MEMP_SEPARATE_POOLS                                                    \
+  1 /* We want the pbuf                                                        \
+       pool cache line                                                         \
+       aligned*/
+#endif
+
+#define MEMP_NUM_SYS_TIMEOUT                                                   \
+  (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2 * LWIP_DHCP) + LWIP_AUTOIP +       \
+   LWIP_IGMP + LWIP_DNS + PPP_SUPPORT)
+
+/*****************************************************************************
+**                           IP Options
+*****************************************************************************/
+#define IP_REASSEMBLY 0
+#define IP_FRAG 0
+
+/*****************************************************************************
+**                           DHCP Options
+*****************************************************************************/
+#define LWIP_DHCP 1
+#define DHCP_DOES_ARP_CHECK 0
+
+/*****************************************************************************
+**                           Auto IP  Options
+*****************************************************************************/
+#define LWIP_AUTOIP 1
+#define LWIP_DHCP_AUTOIP_COOP ((LWIP_DHCP) && (LWIP_AUTOIP))
+
+/*****************************************************************************
+**                           TCP  Options
+*****************************************************************************/
+#define TCP_MSS 1500
+#define TCP_WND (8 * TCP_MSS)
+#define TCP_SND_BUF (8 * TCP_MSS)
+#define TCP_OVERSIZE TCP_MSS
+
+/*****************************************************************************
+**                           PBUF  Options
+*****************************************************************************/
+#define PBUF_LINK_HLEN 14
+#define PBUF_POOL_BUFSIZE                                                      \
+  1520 /* + size of struct pbuf                                                \
+          shall be cache line                                                  \
+          aligned be enabled */
+#define ETH_PAD_SIZE 0
+#define LWIP_NETCONN 1
+
+/*****************************************************************************
+**                           Socket  Options
+*****************************************************************************/
+#define LWIP_SOCKET 1
+
+/*****************************************************************************
+**                          Debugging options
+*****************************************************************************/
+#define LWIP_DBG_MIN_LEVEL LWIP_DBG_LEVEL_OFF
+#define LWIP_DBG_TYPES_ON                                                      \
+  (LWIP_DBG_ON | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_FRESH)
+#define DHCP_DEBUG LWIP_DBG_OFF
+#define NETIF_DEBUG LWIP_DBG_OFF
+#define IP_DEBUG LWIP_DBG_OFF
+#define UDP_DEBUG LWIP_DBG_OFF
+#define ETHARP_DEBUG LWIP_DBG_OFF
+#define SYS_DEBUG LWIP_DBG_OFF
+#define RAW_DEBUG LWIP_DBG_OFF
+#define MEM_DEBUG LWIP_DBG_OFF
+#define MEMP_DEBUG LWIP_DBG_OFF
+#define PBUF_DEBUG LWIP_DBG_OFF
+#define TCPIP_DEBUG LWIP_DBG_OFF
+#define APP_DEBUG LWIP_DBG_OFF
+#define SOCKETS_DEBUG LWIP_DBG_OFF
+#define LWIP_STATS 0
+#define LWIP_STATS_DISPLAY 0
+#define LWIP_STATS_POSIX 0
+
+/**
+ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names.
+ * (only used if you use sockets.c)
+ */
+#define LWIP_COMPAT_SOCKETS 0
+
+#define LWIP_TIMEVAL_PRIVATE 0
+
+#define LWIP_RAW 0
+
+#endif /* __LWIPOPTS_H__ */
diff --git a/contrib/ports/rtems/include/lwipopts.h b/contrib/ports/rtems/include/lwipopts.h
new file mode 100755
index 00000000..b578b293
--- /dev/null
+++ b/contrib/ports/rtems/include/lwipopts.h
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2023 On-Line Applications Research Corporation (OAR)
+ * Written by Kinsey Moore <kinsey.moore@oarcorp.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LWIPOPTS_H__
+#define __LWIPOPTS_H__
+
+/* Critical items that all BSPs must use for full functionality */
+#define SYS_LIGHTWEIGHT_PROT 1
+#define NO_SYS 0
+#define LWIP_SOCKET 1
+#define SO_REUSE 1
+#define LWIP_COMPAT_SOCKETS 1
+#define LWIP_NETCONN 1
+#define LWIP_NETIF_LOOPBACK 1 /* Required for socketpair implementation */
+#define LWIP_NETIF_API 1
+#define LWIP_TIMEVAL_PRIVATE 0
+#define LWIP_CALLBACK_API 1
+#define NO_SYS_NO_TIMERS 1
+#define LWIP_COMPAT_MUTEX 0
+#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 1
+
+#include <common_lwipopts.h>
+
+/* Sane defaults that the configuration or BSP can override */
+
+#ifndef ARP_QUEUEING
+#define ARP_QUEUEING 1
+#endif
+
+#ifndef ARP_TABLE_SIZE
+#define ARP_TABLE_SIZE 10
+#endif
+
+#ifndef CHECKSUM_CHECK_IP
+#define CHECKSUM_CHECK_IP 1
+#endif
+
+#ifndef CHECKSUM_CHECK_TCP
+#define CHECKSUM_CHECK_TCP 1
+#endif
+
+#ifndef CHECKSUM_CHECK_UDP
+#define CHECKSUM_CHECK_UDP 1
+#endif
+
+#ifndef CHECKSUM_GEN_IP
+#define CHECKSUM_GEN_IP 1
+#endif
+
+#ifndef CHECKSUM_GEN_TCP
+#define CHECKSUM_GEN_TCP 1
+#endif
+
+#ifndef CHECKSUM_GEN_UDP
+#define CHECKSUM_GEN_UDP 1
+#endif
+
+#ifndef CONFIG_LINKSPEED_AUTODETECT
+#define CONFIG_LINKSPEED_AUTODETECT 1
+#endif
+
+#ifndef DEFAULT_ACCEPTMBOX_SIZE
+#define DEFAULT_ACCEPTMBOX_SIZE 5
+#endif
+
+#ifndef DEFAULT_TCP_RECVMBOX_SIZE
+#define DEFAULT_TCP_RECVMBOX_SIZE 20
+#endif
+
+#ifndef DEFAULT_UDP_RECVMBOX_SIZE
+#define DEFAULT_UDP_RECVMBOX_SIZE 20
+#endif
+
+#ifndef DHCP_DOES_ARP_CHECK
+#define DHCP_DOES_ARP_CHECK 1
+#endif
+
+#ifndef ICMP_TTL
+#define ICMP_TTL 255
+#endif
+
+#ifndef IP_DEFAULT_TTL
+#define IP_DEFAULT_TTL 255
+#endif
+
+#ifndef IP_FORWARD
+#define IP_FORWARD 0
+#endif
+
+#ifndef IP_FRAG
+#define IP_FRAG 1
+#endif
+
+#ifndef IP_FRAG_MAX_MTU
+#define IP_FRAG_MAX_MTU 1500
+#endif
+
+#ifndef IP_OPTIONS
+#define IP_OPTIONS 1
+#endif
+
+#ifndef IP_OPTIONS_ALLOWED
+#define IP_OPTIONS_ALLOWED 0
+#endif
+
+#ifndef IP_REASS_BUFSIZE
+#define IP_REASS_BUFSIZE 5760
+#endif
+
+#ifndef IP_REASSEMBLY
+#define IP_REASSEMBLY 1
+#endif
+
+#ifndef LWIP_ARP
+#define LWIP_ARP 1
+#endif
+
+#ifndef LWIP_AUTOIP
+#define LWIP_AUTOIP 1
+#endif
+
+#ifndef LWIP_CHKSUM_ALGORITHM
+#define LWIP_CHKSUM_ALGORITHM 3
+#endif
+
+#ifndef LWIP_DHCP
+#define LWIP_DHCP 1
+#endif
+
+#ifndef LWIP_DHCP_AUTOIP_COOP
+#define LWIP_DHCP_AUTOIP_COOP ((LWIP_DHCP) && (LWIP_AUTOIP))
+#endif
+
+#ifndef LWIP_DNS
+#define LWIP_DNS 1
+#endif
+
+#ifndef LWIP_IPV4
+#define LWIP_IPV4 1
+#endif
+
+#ifndef LWIP_IPV6
+#define LWIP_IPV6 1
+#endif
+
+#ifndef LWIP_TCP
+#define LWIP_TCP 1
+#endif
+
+#ifndef LWIP_UDP
+#define LWIP_UDP 1
+#endif
+
+#ifndef MEMP_NUM_FRAG_PBUF
+#define MEMP_NUM_FRAG_PBUF 256
+#endif
+
+#ifndef MEMP_NUM_NETCONN
+#define MEMP_NUM_NETCONN 16
+#endif
+
+#ifndef MEMP_NUM_PBUF
+#define MEMP_NUM_PBUF 96
+#endif
+
+#ifndef MEMP_NUM_TCP_PCB
+#define MEMP_NUM_TCP_PCB 32
+#endif
+
+#ifndef MEMP_NUM_TCP_PCB_LISTEN
+#define MEMP_NUM_TCP_PCB_LISTEN 8
+#endif
+
+#ifndef MEMP_NUM_TCP_SEG
+#define MEMP_NUM_TCP_SEG 256
+#endif
+
+#ifndef MEMP_NUM_UDP_PCB
+#define MEMP_NUM_UDP_PCB 16
+#endif
+
+#ifndef MEMP_SEPARATE_POOLS
+#define MEMP_SEPARATE_POOLS 1
+#endif
+
+#ifndef MEM_SIZE
+#define MEM_SIZE 2 * 1024 * 1024
+#endif
+
+#ifndef PBUF_LINK_HLEN
+#define PBUF_LINK_HLEN 16
+#endif
+
+#ifndef PBUF_POOL_BUFSIZE
+#define PBUF_POOL_BUFSIZE 1600
+#endif
+
+#ifndef PBUF_POOL_SIZE
+#define PBUF_POOL_SIZE 512
+#endif
+
+#ifndef TCP_FAST_INTERVAL
+#define TCP_FAST_INTERVAL 250
+#endif
+
+#ifndef TCPIP_MBOX_SIZE
+#define TCPIP_MBOX_SIZE 20
+#endif
+
+#ifndef TCP_MAXRTX
+#define TCP_MAXRTX 12
+#endif
+
+#ifndef TCP_MSS
+#define TCP_MSS 1576
+#endif
+
+#ifndef TCP_OVERSIZE
+#define TCP_OVERSIZE TCP_MSS
+#endif
+
+#ifndef TCP_QUEUE_OOSEQ
+#define TCP_QUEUE_OOSEQ 1
+#endif
+
+#ifndef TCP_SLOW_INTERVAL
+#define TCP_SLOW_INTERVAL 500
+#endif
+
+#ifndef TCP_SND_BUF
+#define TCP_SND_BUF (8 * TCP_MSS)
+#endif
+
+#ifndef TCP_SND_QUEUELEN
+#define TCP_SND_QUEUELEN 16 * TCP_SND_BUF / TCP_MSS
+#endif
+
+#ifndef TCP_SYNMAXRTX
+#define TCP_SYNMAXRTX 4
+#endif
+
+#ifndef TCP_TMR_INTERVAL
+#define TCP_TMR_INTERVAL 250
+#endif
+
+#ifndef TCP_TTL
+#define TCP_TTL 255
+#endif
+
+#ifndef TCP_WND
+#define TCP_WND (8 * TCP_MSS)
+#endif
+
+#ifndef UDP_TTL
+#define UDP_TTL 255
+#endif
+
+#endif /* __LWIPOPTS_H__ */
diff --git a/contrib/ports/rtems/sys_arch.c b/contrib/ports/rtems/sys_arch.c
new file mode 100644
index 00000000..6e5d5d26
--- /dev/null
+++ b/contrib/ports/rtems/sys_arch.c
@@ -0,0 +1,326 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file is system adaptation of the lwIP TCP/IP stack
+ * by Adam Dunkels <adam@sics.se> for RTEMS system.
+ *
+ * Author: Premysl Houdek <houdepre@fel.cvut.cz>
+ * Mentor: Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ * Industrial Informatics Group, FEE, Czech Technical University in Prague
+ *
+ */
+/*
+ * mapping of lwIP system dependencies to RTEMS system services and types.
+ * DETAILS: ./lwip/doc/sys_arch.txt
+ */
+
+#include "lwip/err.h"
+#include "lwip/tcpip.h"
+#include "lwipopts.h"
+#include <arch/cc.h>
+#include <arch/sys_arch.h>
+#include <rtems.h>
+#include <rtems/rtems/clock.h>
+#include <rtems/rtems/sem.h>
+#include <stdint.h>
+
+#define SYS_LWIP_MBOX_SIZE (sizeof(void *))
+
+uint32_t sys_now() {
+  uint64_t temp = rtems_clock_get_uptime_nanoseconds() / (1000 * 1000);
+
+  return temp;
+}
+
+#if RTEMS_SMP
+#include <rtems/thread.h>
+rtems_recursive_mutex sys_arch_lock =
+    RTEMS_RECURSIVE_MUTEX_INITIALIZER("LWIP System Protection Lock");
+#endif
+
+void sys_init(void) {
+  //  Is called to initialize the sys_arch layer.
+  return;
+}
+
+err_t sys_sem_new(sys_sem_t *sem, u8_t count) {
+  rtems_status_code ret =
+      rtems_semaphore_create(rtems_build_name('L', 'W', 'I', 'P'), count,
+                             RTEMS_COUNTING_SEMAPHORE, 0, &sem->semaphore);
+
+  if (ret != RTEMS_SUCCESSFUL) {
+    sem->semaphore = RTEMS_ID_NONE;
+    return ret;
+  }
+  return ERR_OK;
+}
+
+void sys_sem_free(sys_sem_t *sem) {
+  rtems_semaphore_delete(sem->semaphore);
+  sem->semaphore = RTEMS_ID_NONE;
+}
+
+void sys_sem_signal(sys_sem_t *sem) { rtems_semaphore_release(sem->semaphore); }
+
+void sys_sem_signal_from_ISR(sys_sem_t *sem) {
+  rtems_semaphore_release(sem->semaphore);
+}
+
+u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout) {
+  rtems_status_code status;
+  rtems_interval tps = rtems_clock_get_ticks_per_second();
+  rtems_interval tick_timeout;
+  uint64_t start_time;
+  uint64_t wait_time;
+
+  start_time = rtems_clock_get_uptime_nanoseconds();
+  if (timeout == 0) {
+    tick_timeout = RTEMS_NO_TIMEOUT;
+  } else {
+    tick_timeout = (timeout * tps + 999) / 1000;
+  }
+  status = rtems_semaphore_obtain(sem->semaphore, RTEMS_WAIT, tick_timeout);
+  if (status == RTEMS_TIMEOUT) {
+    return SYS_ARCH_TIMEOUT;
+  }
+  if (status != RTEMS_SUCCESSFUL) {
+    return SYS_ARCH_TIMEOUT;
+  }
+  wait_time = rtems_clock_get_uptime_nanoseconds() - start_time;
+  return wait_time / (1000 * 1000);
+}
+
+int sys_sem_valid(sys_sem_t *sem) {
+  return sem->semaphore == RTEMS_ID_NONE ? 0 : 1;
+}
+
+void sys_sem_set_invalid(sys_sem_t *sem) { sem->semaphore = RTEMS_ID_NONE; }
+
+err_t sys_mbox_new(sys_mbox_t *mbox, int size) {
+  rtems_status_code ret;
+
+  ret = rtems_message_queue_create(rtems_build_name('L', 'W', 'I', 'P'), size,
+                                   SYS_LWIP_MBOX_SIZE, 0, &mbox->mailbox);
+  ret |= rtems_semaphore_create(rtems_build_name('L', 'W', 'I', 'P'), size,
+                                RTEMS_COUNTING_SEMAPHORE, 0, &mbox->sem);
+  if (ret != RTEMS_SUCCESSFUL) {
+    mbox->mailbox = RTEMS_ID_NONE;
+    mbox->sem = RTEMS_ID_NONE;
+    return ret;
+  }
+  return ERR_OK;
+}
+
+void sys_mbox_free(sys_mbox_t *mbox) {
+  rtems_message_queue_delete(mbox->mailbox);
+  rtems_semaphore_delete(mbox->sem);
+  sys_mbox_set_invalid(mbox);
+}
+
+void sys_mbox_post(sys_mbox_t *mbox, void *msg) {
+  rtems_semaphore_obtain(mbox->sem, RTEMS_WAIT, RTEMS_NO_TIMEOUT);
+  rtems_message_queue_send(mbox->mailbox, &msg, SYS_LWIP_MBOX_SIZE);
+}
+err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg) {
+  rtems_status_code status =
+      rtems_semaphore_obtain(mbox->sem, RTEMS_NO_WAIT, 0);
+
+  if (status != RTEMS_SUCCESSFUL) {
+    return ERR_MEM;
+  } else {
+    rtems_message_queue_send(mbox->mailbox, &msg, SYS_LWIP_MBOX_SIZE);
+    return ERR_OK;
+  }
+}
+
+u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout) {
+  rtems_status_code status;
+  rtems_interval tps = rtems_clock_get_ticks_per_second();
+  rtems_interval tick_timeout;
+  uint64_t start_time;
+  uint64_t wait_time;
+  size_t dummy;
+
+  start_time = rtems_clock_get_uptime_nanoseconds();
+  if (timeout == 0) {
+    tick_timeout = RTEMS_NO_TIMEOUT;
+  } else {
+    tick_timeout = (timeout * tps + 999) / 1000;
+  }
+  status = rtems_message_queue_receive(mbox->mailbox, msg, &dummy, RTEMS_WAIT,
+                                       tick_timeout);
+  if (status == RTEMS_TIMEOUT) {
+    return SYS_ARCH_TIMEOUT;
+  }
+  if (status != RTEMS_SUCCESSFUL) {
+    return SYS_ARCH_TIMEOUT;
+  }
+  wait_time = rtems_clock_get_uptime_nanoseconds() - start_time;
+  rtems_semaphore_release(mbox->sem);
+  return wait_time / (1000 * 1000);
+}
+
+u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg) {
+  rtems_status_code status;
+  size_t dummy;
+
+  status =
+      rtems_message_queue_receive(mbox->mailbox, msg, &dummy, RTEMS_NO_WAIT, 0);
+
+  if (status != RTEMS_SUCCESSFUL) {
+    return SYS_MBOX_EMPTY;
+  } else {
+    rtems_semaphore_release(mbox->sem);
+    return 0;
+  }
+}
+int sys_mbox_valid(sys_mbox_t *mbox) {
+  return mbox->mailbox == RTEMS_ID_NONE ? 0 : 1;
+}
+void sys_mbox_set_invalid(sys_mbox_t *mbox) {
+  mbox->sem = RTEMS_ID_NONE;
+  mbox->mailbox = RTEMS_ID_NONE;
+}
+
+sys_thread_t sys_thread_new(const char *name, lwip_thread_fn function,
+                            void *arg, int stack_size, int prio) {
+  rtems_id id;
+  rtems_status_code res;
+
+  res = rtems_task_create(rtems_build_name(name[0], name[1], name[2], name[3]),
+                          prio, stack_size, RTEMS_PREEMPT, 0, &id);
+
+  if (res != RTEMS_SUCCESSFUL) {
+    return 0;
+  }
+
+  res = rtems_task_start(id, (rtems_task_entry)function,
+                         (rtems_task_argument)arg);
+
+  if (res != RTEMS_SUCCESSFUL) {
+    rtems_task_delete(id);
+    return 0;
+  }
+  return id;
+}
+
+sys_thread_t sys_thread_new_affinity(const char *name, lwip_thread_fn function,
+                                     void *arg, int stack_size, int prio,
+                                     cpu_set_t *set) {
+  rtems_id id;
+  rtems_status_code res;
+
+  res = rtems_task_create(rtems_build_name(name[0], name[1], name[2], name[3]),
+                          prio, stack_size, RTEMS_PREEMPT, 0, &id);
+
+  if (res != RTEMS_SUCCESSFUL) {
+    return 0;
+  }
+
+  res = rtems_task_set_affinity(id, sizeof(cpu_set_t), set);
+
+  if (res != RTEMS_SUCCESSFUL) {
+    return 0;
+  }
+
+  res = rtems_task_start(id, (rtems_task_entry)function,
+                         (rtems_task_argument)arg);
+
+  if (res != RTEMS_SUCCESSFUL) {
+    rtems_task_delete(id);
+    return 0;
+  }
+  return id;
+}
+
+err_t sys_mutex_new(sys_mutex_t *mutex) {
+  rtems_status_code ret =
+      rtems_semaphore_create(rtems_build_name('L', 'W', 'I', 'P'), 1,
+                             RTEMS_PRIORITY | RTEMS_BINARY_SEMAPHORE |
+                                 RTEMS_INHERIT_PRIORITY | RTEMS_LOCAL,
+                             0, &mutex->mutex);
+
+  if (ret != RTEMS_SUCCESSFUL) {
+    mutex->mutex = RTEMS_ID_NONE;
+    return ret;
+  }
+  return ERR_OK;
+}
+/** Lock a mutex
+ * @param mutex the mutex to lock */
+void sys_mutex_lock(sys_mutex_t *mutex) {
+  rtems_semaphore_obtain(mutex->mutex, RTEMS_WAIT, RTEMS_NO_TIMEOUT);
+}
+/** Unlock a mutex
+ * @param mutex the mutex to unlock */
+void sys_mutex_unlock(sys_mutex_t *mutex) {
+  rtems_semaphore_release(mutex->mutex);
+}
+/** Delete a semaphore
+ * @param mutex the mutex to delete */
+void sys_mutex_free(sys_mutex_t *mutex) {
+  rtems_semaphore_delete(mutex->mutex);
+}
+
+void sys_arch_delay(unsigned int timeout) {
+  rtems_interval tps = rtems_clock_get_ticks_per_second();
+  rtems_interval tick_timeout = (timeout * tps + 999) / 1000;
+
+  rtems_task_wake_after(tick_timeout);
+}
+
+/** Ticks/jiffies since power up. */
+uint32_t sys_jiffies(void) { return rtems_clock_get_ticks_since_boot(); }
+
+int sys_request_irq(unsigned int irqnum, sys_irq_handler_t handler,
+                    unsigned long flags, const char *name, void *context) {
+  rtems_status_code res;
+
+  res = rtems_interrupt_handler_install(irqnum, name, flags, handler, context);
+  return (res != RTEMS_SUCCESSFUL) ? -1 : 0;
+}
+
+sys_prot_t sys_arch_protect() {
+  sys_prot_t pval = 0;
+
+#if RTEMS_SMP
+  rtems_recursive_mutex_lock(&sys_arch_lock);
+#else
+  rtems_interrupt_disable(pval);
+#endif
+  return pval;
+}
+
+void sys_arch_unprotect(sys_prot_t pval) {
+#if RTEMS_SMP
+  rtems_recursive_mutex_unlock(&sys_arch_lock);
+#else
+  rtems_interrupt_enable(pval);
+#endif
+}
+err_t sys_mbox_trypost_fromisr(sys_mbox_t *q, void *msg) {
+  return sys_mbox_trypost(q, msg);
+}
diff --git a/src/include/lwip/opt.h b/src/include/lwip/opt.h
index c27dd034..4b3b7afa 100644
--- a/src/include/lwip/opt.h
+++ b/src/include/lwip/opt.h
@@ -1813,7 +1813,7 @@
  * sys_thread_new() when the thread is created.
  */
 #if !defined TCPIP_THREAD_STACKSIZE || defined __DOXYGEN__
-#define TCPIP_THREAD_STACKSIZE          0
+#define TCPIP_THREAD_STACKSIZE          2048
 #endif
 
 /**
